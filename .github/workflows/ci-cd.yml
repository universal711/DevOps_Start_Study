name: CI/CD - Fixed Version

on:
  push:
    branches: [ main ]

env:
  IMAGE_NAME: visit-counter
  K8S_NAMESPACE: visit-counter

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Build and test Docker image
      run: |
        # Build image
        docker build -t ${{ env.IMAGE_NAME }}:test .
        
        # Test on different port
        docker run -d --name test-container -p 3080:3000 ${{ env.IMAGE_NAME }}:test
        sleep 5
        curl -f http://localhost:3080/health
        curl -f http://localhost:3080/
        docker stop test-container
        docker rm test-container
        echo "âœ… Docker image tested successfully"

  deploy-to-kubernetes:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Minikube and kubectl
      run: |
        # Install kubectl
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        
        # Install Minikube
        curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
        chmod +x minikube-linux-amd64
        sudo mv minikube-linux-amd64 /usr/local/bin/minikube

    - name: Start Minikube cluster
      run: |
        minikube start --driver=docker --memory=4096 --cpus=2 --force
        minikube status
        
        # ĞĞ°ÑÑ‚Ñ€Ğ°Ğ¸Ğ²Ğ°ĞµĞ¼ Docker Ğ´Ğ»Ñ Minikube
        eval $(minikube docker-env)

    - name: Build image in Minikube environment
      run: |
        # Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ¾Ğ±Ñ€Ğ°Ğ· Ğ’ĞĞ£Ğ¢Ğ Ğ˜ Minikube Docker daemon
        docker build -t ${{ env.IMAGE_NAME }}:latest .
        echo "âœ… Image built inside Minikube"
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ‡Ñ‚Ğ¾ Ğ¾Ğ±Ñ€Ğ°Ğ· ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚ Ğ² Minikube
        echo "ğŸ“‹ Available images in Minikube:"
        docker images | grep ${{ env.IMAGE_NAME }}

    - name: Prepare Kubernetes manifests
      run: |
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğ¹ deployment Ñ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ°Ğ¼Ğ¸
        cat > deployment-temp.yaml << DEPLOYMENTEOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: visit-counter
  namespace: ${{ env.K8S_NAMESPACE }}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: visit-counter
  template:
    metadata:
      labels:
        app: visit-counter
    spec:
      containers:
      - name: visit-counter
        image: ${{ env.IMAGE_NAME }}:latest
        imagePullPolicy: Never  
        ports:
        - containerPort: 3000
        env:
        - name: PORT
          value: "3000"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 15
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
DEPLOYMENTEOF

    - name: Deploy application
      run: |
        # Create namespace
        kubectl create namespace ${{ env.K8S_NAMESPACE }} || true
        
        # Apply basic manifests
        kubectl apply -f kubernetes/namespace.yaml
        kubectl apply -f kubernetes/configmap.yaml
        kubectl apply -f kubernetes/secret.yaml
        kubectl apply -f kubernetes/service-account.yaml
        
        # Apply our custom deployment
        kubectl apply -f deployment-temp.yaml
        
        # Apply service
        kubectl apply -f kubernetes/service.yaml
        
        echo "âœ… Kubernetes resources applied"



    - name: Wait for deployment with better diagnostics
      run: |
        echo "â³ Waiting for deployment to be ready..."
        
        # Show initial status
        kubectl get all -n ${{ env.K8S_NAMESPACE }}
        
        # Wait for deployment with detailed output
        for i in {1..30}; do
          echo "Attempt $i/30"
          
          # Get detailed pod status
          POD_NAME=$(kubectl get pods -n ${{ env.K8S_NAMESPACE }} -l app=visit-counter -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "NOT_FOUND")
          POD_STATUS=$(kubectl get pods -n ${{ env.K8S_NAMESPACE }} -l app=visit-counter -o jsonpath='{.items[0].status.phase}' 2>/dev/null || echo "NOT_FOUND")
          
          echo "Pod: $POD_NAME, Status: $POD_STATUS"
          
          if [ "$POD_STATUS" = "Running" ]; then
            echo "âœ… Pod is running!"
            break
          fi
          
          if [ "$POD_STATUS" = "Failed" ] || [ "$POD_STATUS" = "Error" ]; then
            echo "âŒ Pod failed. Details:"
            kubectl describe pods -n ${{ env.K8S_NAMESPACE }} -l app=visit-counter
            kubectl logs -n ${{ env.K8S_NAMESPACE }} -l app=visit-counter --tail=20
            exit 1
          fi
          
          # Show events for debugging
          if [ "$i" -eq 1 ] || [ "$i" -eq 10 ] || [ "$i" -eq 20 ]; then
            echo "ğŸ“‹ Recent events:"
            kubectl get events -n ${{ env.K8S_NAMESPACE }} --sort-by=.lastTimestamp | tail -5
          fi
          
          sleep 5
        done
        
        if [ "$POD_STATUS" != "Running" ]; then
          echo "âŒ Timeout waiting for pod"
          echo "=== Final debugging ==="
          kubectl get all -n ${{ env.K8S_NAMESPACE }}
          kubectl describe pods -n ${{ env.K8S_NAMESPACE }} -l app=visit-counter
          exit 1
        fi

    - name: Test deployed application
      run: |
        echo "ğŸ§ª Testing deployed application..."
        
        # Port forward
        kubectl port-forward -n ${{ env.K8S_NAMESPACE }} service/visit-counter-service 3081:80 &
        PORT_FORWARD_PID=$!
        sleep 10
        
        # Test endpoints
        curl -f http://localhost:3081/health || (echo "Health check failed" && exit 1)
        curl -f http://localhost:3081/ || (echo "Main endpoint failed" && exit 1)
        
        # Cleanup
        kill $PORT_FORWARD_PID 2>/dev/null || true
        echo "âœ… All tests passed!"

    - name: Success
      run: |
        echo "ğŸ‰ ğŸ‰ ğŸ‰ SUCCESS! ğŸ‰ ğŸ‰ ğŸ‰"
        echo "âœ… Application successfully deployed to Kubernetes!"
        echo "ğŸ“Š Final status:"
        kubectl get all -n ${{ env.K8S_NAMESPACE }}

