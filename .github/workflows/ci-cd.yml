name: CI/CD - Reliable Version

on:
  push:
    branches: [ main ]

env:
  IMAGE_NAME: visit-counter
  K8S_NAMESPACE: visit-counter

jobs:
  test-and-build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Test Node.js application
      run: |
        cd app
        npm ci
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∏ –∑–∞–ø–æ–º–∏–Ω–∞–µ–º PID
        npm start &
        SERVER_PID=$!
        sleep 5
        
        # –¢–µ—Å—Ç–∏—Ä—É–µ–º
        curl -f http://localhost:3000/health
        curl -f http://localhost:3000/
        
        # –û–°–¢–ê–ù–ê–í–õ–ò–í–ê–ï–ú –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –ø–æ—Å–ª–µ —Ç–µ—Å—Ç–æ–≤
        kill $SERVER_PID || true
        sleep 2
        echo "‚úÖ Node.js app tested and stopped!"

    - name: Build Docker image
      run: |
        docker build -t ${{ env.IMAGE_NAME }}:test .
        echo "‚úÖ Docker image built successfully"

    - name: Test Docker image locally
      run: |
        # –£–±–µ–¥–∏–º—Å—è —á—Ç–æ –ø–æ—Ä—Ç —Å–≤–æ–±–æ–¥–µ–Ω
        docker run -d --name test-container -p 3000:3000 ${{ env.IMAGE_NAME }}:test
        sleep 5
        curl -f http://localhost:3000/health
        curl -f http://localhost:3000/stats
        docker stop test-container
        docker rm test-container
        echo "‚úÖ Docker container works perfectly!"

  simple-deploy:
    needs: test-and-build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Minikube
      run: |
        # Install kubectl
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        
        # Install Minikube
        curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
        chmod +x minikube-linux-amd64
        sudo mv minikube-linux-amd64 /usr/local/bin/minikube

    - name: Start Minikube with sufficient resources
      run: |
        minikube start --driver=docker --memory=4096 --cpus=2 --force
        minikube status
        eval $(minikube docker-env)

    - name: Build image inside Minikube
      run: |
        docker build -t ${{ env.IMAGE_NAME }}:latest .
        echo "‚úÖ Image built inside Minikube"

    - name: Create simple deployment
      run: |
        # Create namespace
        kubectl create namespace ${{ env.K8S_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
        
        # Create simple deployment with only essential components
        cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: visit-counter
          namespace: ${{ env.K8S_NAMESPACE }}
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: visit-counter
          template:
            metadata:
              labels:
                app: visit-counter
            spec:
              containers:
              - name: visit-counter
                image: ${{ env.IMAGE_NAME }}:latest
                imagePullPolicy: IfNotPresent
                ports:
                - containerPort: 3000
                env:
                - name: PORT
                  value: "3000"
                resources:
                  requests:
                    memory: "128Mi"
                    cpu: "100m"
                  limits:
                    memory: "256Mi"
                    cpu: "200m"
        EOF

    - name: Create service
      run: |
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: Service
        metadata:
          name: visit-counter-service
          namespace: ${{ env.K8S_NAMESPACE }}
        spec:
          selector:
            app: visit-counter
          ports:
          - protocol: TCP
            port: 80
            targetPort: 3000
          type: LoadBalancer
        EOF

    - name: Wait for pod with detailed debugging
      run: |
        echo "üïí Waiting for pod to be ready..."
        
        # Wait up to 3 minutes for pod
        for i in {1..36}; do
          echo "Attempt $i/36"
          
          # Get pod status
          POD_STATUS=$(kubectl get pods -n ${{ env.K8S_NAMESPACE }} -l app=visit-counter -o jsonpath='{.items[0].status.phase}' 2>/dev/null || echo "No pod")
          echo "Pod status: $POD_STATUS"
          
          # Get pod details if exists
          if [ "$POD_STATUS" != "No pod" ]; then
            kubectl get pods -n ${{ env.K8S_NAMESPACE }} -o wide
          fi
          
          # Check if pod is running
          if [ "$POD_STATUS" = "Running" ]; then
            echo "‚úÖ Pod is running!"
            break
          fi
          
          # If pod failed, show why
          if [ "$POD_STATUS" = "Failed" ] || [ "$POD_STATUS" = "Error" ]; then
            echo "‚ùå Pod failed. Showing details:"
            kubectl describe pods -n ${{ env.K8S_NAMESPACE }} -l app=visit-counter
            kubectl logs -n ${{ env.K8S_NAMESPACE }} -l app=visit-counter --tail=20
            exit 1
          fi
          
          sleep 5
        done
        
        # Final check
        if [ "$POD_STATUS" != "Running" ]; then
          echo "‚ùå Timeout waiting for pod. Current status: $POD_STATUS"
          echo "=== Debugging info ==="
          kubectl get all -n ${{ env.K8S_NAMESPACE }}
          kubectl describe pods -n ${{ env.K8S_NAMESPACE }} -l app=visit-counter 2>/dev/null || echo "No pods to describe"
          exit 1
        fi

    - name: Test the deployed application
      run: |
        echo "üöÄ Testing deployed application..."
        
        # Port forward in background
        kubectl port-forward -n ${{ env.K8S_NAMESPACE }} service/visit-counter-service 8080:80 &
        PORT_FORWARD_PID=$!
        sleep 10
        
        # Test with retries
        for i in {1..5}; do
          echo "Test attempt $i"
          if curl -f http://localhost:8080/health; then
            echo "‚úÖ Health check passed!"
            if curl -f http://localhost:8080/; then
              echo "‚úÖ Main endpoint passed!"
              break
            fi
          fi
          sleep 5
        done
        
        # Cleanup
        kill $PORT_FORWARD_PID 2>/dev/null || true

    - name: Show success message
      run: |
        echo "üéâ SUCCESS! Application deployed and tested in Kubernetes!"
        echo "üìä Cluster status:"
        kubectl get all -n ${{ env.K8S_NAMESPACE }}
