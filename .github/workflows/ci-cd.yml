name: CI/CD - Final Version

on:
  push:
    branches: [ main ]

env:
  IMAGE_NAME: visit-counter
  K8S_NAMESPACE: visit-counter

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Validate application structure
      run: |
        echo "üîç Validating project structure..."
        ls -la app/
        test -f app/package.json && echo "‚úÖ package.json exists"
        test -f app/server.js && echo "‚úÖ server.js exists"
        test -f Dockerfile && echo "‚úÖ Dockerfile exists"

    - name: Install dependencies
      run: |
        cd app
        npm ci
        echo "‚úÖ Dependencies installed"

    - name: Build Docker image
      run: |
        docker build -t ${{ env.IMAGE_NAME }}:test .
        echo "‚úÖ Docker image built"

    - name: Test Docker container
      run: |
        # –ó–∞–ø—É—Å–∫–∞–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –Ω–∞ –ü–û–õ–ù–û–°–¢–¨–Æ –°–í–û–ë–û–î–ù–û–ú –ø–æ—Ä—Ç—É
        docker run -d --name test-container -p 3080:3000 ${{ env.IMAGE_NAME }}:test
        sleep 5
        
        # –¢–µ—Å—Ç–∏—Ä—É–µ–º –Ω–∞ –ø–æ—Ä—Ç—É 3080 (–Ω–µ 3000!)
        curl -f http://localhost:3080/health || (docker logs test-container && exit 1)
        curl -f http://localhost:3080/ || (docker logs test-container && exit 1)
        curl -f http://localhost:3080/stats || (docker logs test-container && exit 1)
        
        docker stop test-container
        docker rm test-container
        echo "‚úÖ Docker container tested successfully on port 3080"

  deploy-to-kubernetes:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Minikube and kubectl
      run: |
        echo "üöÄ Setting up Kubernetes environment..."
        
        # Install kubectl
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        
        # Install Minikube
        curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
        chmod +x minikube-linux-amd64
        sudo mv minikube-linux-amd64 /usr/local/bin/minikube

    - name: Start Minikube cluster
      run: |
        minikube start --driver=docker --memory=4096 --cpus=2 --force
        echo "‚úÖ Minikube started"
        minikube status
        eval $(minikube docker-env)

    - name: Build image in Minikube environment
      run: |
        docker build -t ${{ env.IMAGE_NAME }}:latest .
        echo "‚úÖ Image built in Minikube"

    - name: Deploy application
      run: |
        # Create namespace
        kubectl create namespace ${{ env.K8S_NAMESPACE }} || true
        
        # Apply Kubernetes manifests
        kubectl apply -f kubernetes/namespace.yaml
        kubectl apply -f kubernetes/configmap.yaml
        kubectl apply -f kubernetes/secret.yaml
        kubectl apply -f kubernetes/service-account.yaml
        
        # Use single replica for faster deployment
        cat <<EOF | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: visit-counter
  namespace: ${{ env.K8S_NAMESPACE }}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: visit-counter
  template:
    metadata:
      labels:
        app: visit-counter
    spec:
      containers:
      - name: visit-counter
        image: ${{ env.IMAGE_NAME }}:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 3000
        env:
        - name: PORT
          value: "3000"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 10
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
