name: CI/CD for Visit Counter

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  IMAGE_NAME: visit-counter
  REGISTRY: ghcr.io
  K8S_NAMESPACE: visit-counter

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: app/package-lock.json

    - name: Install dependencies
      run: |
        cd app
        npm ci

    - name: Run basic tests
      run: |
        cd app
        npm start &
        sleep 5
        curl -f http://localhost:3000/health || exit 1
        curl -f http://localhost:3000/ || exit 1
        kill %1

  deploy-to-minikube:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Minikube and kubectl
      run: |
        # Install kubectl
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
        
        # Install Minikube
        curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
        sudo install minikube-linux-amd64 /usr/local/bin/minikube

    - name: Start Minikube cluster
      run: |
        # Start Minikube with Docker driver
        minikube start --driver=docker --force
        minikube status
        
        # Configure Docker to use Minikube's Docker daemon
        eval $(minikube docker-env)

    - name: Build Docker image in Minikube
      run: |
        docker build -t ${{ env.IMAGE_NAME }}:latest .

    - name: Deploy to Kubernetes
      run: |
        # Create namespace if not exists
        kubectl create namespace ${{ env.K8S_NAMESPACE }} || true
        
        # Apply basic manifests first
        kubectl apply -f kubernetes/namespace.yaml
        kubectl apply -f kubernetes/configmap.yaml
        kubectl apply -f kubernetes/secret.yaml
        kubectl apply -f kubernetes/service-account.yaml

        # Create a temporary deployment file with correct settings for Minikube
        cat > deployment-minikube.yaml << 'DEPLOYMENT_EOF'
apiVersion: apps/v1
kind: Deployment
metadata:
  name: visit-counter
  namespace: ${{ env.K8S_NAMESPACE }}
  labels:
    app: visit-counter
spec:
  replicas: 1
  selector:
    matchLabels:
      app: visit-counter
  template:
    metadata:
      labels:
        app: visit-counter
    spec:
      containers:
      - name: visit-counter
        image: ${{ env.IMAGE_NAME }}:latest
        imagePullPolicy: Never  # Critical for Minikube
        ports:
        - containerPort: 3000
        env:
        - name: PORT
          value: "3000"
        - name: NODE_ENV
          value: "production"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
DEPLOYMENT_EOF

        # Apply our custom deployment
        kubectl apply -f deployment-minikube.yaml
        
        # Apply other resources
        kubectl apply -f kubernetes/service.yaml
        kubectl apply -f kubernetes/hpa.yaml || true

    - name: Wait for deployment
      run: |
        echo "â³ Waiting for deployment to be ready..."
        kubectl rollout status deployment/visit-counter -n ${{ env.K8S_NAMESPACE }} --timeout=300s

    - name: Verify deployment
      run: |
        echo "âœ… Deployment verification"
        kubectl get all -n ${{ env.K8S_NAMESPACE }}

    - name: Run smoke tests
      run: |
        echo "ğŸ§ª Running smoke tests..."
        
        # Start port-forward in background
        kubectl port-forward service/visit-counter-service 8080:80 -n ${{ env.K8S_NAMESPACE }} &
        PORT_FORWARD_PID=$!
        
        # Wait for port-forward to be ready
        sleep 10
        
        # Test endpoints
        curl -f http://localhost:8080/health || exit 1
        curl -f http://localhost:8080/ || exit 1
        
        # Stop port-forward
        kill $PORT_FORWARD_PID
        echo "âœ… Smoke tests passed!"

    - name: Get Minikube service URL
      run: |
        minikube service list -n ${{ env.K8S_NAMESPACE }}
